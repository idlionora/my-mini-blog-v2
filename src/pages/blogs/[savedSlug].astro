---
export const prerender = true;
import BlogPage from "@components/BlogPage.astro"
import type { GetStaticPaths, MarkdownInstance } from "astro";
import "@styles/blogs.css"

export const getStaticPaths =(async () => {
	const allSavedPosts: MarkdownInstance<Record<string, any>>[] = await Astro.glob("@data/blogposts/*.md");
	const frontmatters = allSavedPosts.map((blogpost) => blogpost.frontmatter);
	
	return frontmatters.map((blog) => { return {
		params: {savedSlug: blog.slug},
		props: blog
	}})
}) satisfies GetStaticPaths;

const {id, title, summary, slug, blogpostImg, blogthumbImg, bannerImg, content, tags, createdAt, updatedAt, user, commentCount} = Astro.props;
---
<BlogPage {id} {title} {bannerImg} {content} {tags} {createdAt} {updatedAt} {user} />

<script>
	import fetchExploreCards from "@scripts/fetchExploreCards"

	const blogpostArticle = document.getElementById('blogpost-article')
	const currentBlogId = blogpostArticle?.dataset.blogid;
	const tagList = document.getElementById('tag-list')
	const tagString = tagList?.dataset.tags;
	const expCardContainer = document.getElementById('explore-card-container');
	const exploreFetchMesage = document.getElementById('explore-fetch-message');
	
	// fetchExploreCards({tagString, excludedId: currentBlogId, cardContainer: expCardContainer, fetchingMessage: exploreFetchMesage});
</script>
<script>
	import axios from 'axios';
	import CommentSection from '@scripts/commentSectionClass';
	import { commentEditArea, commentContent } from '@scripts/commentCard';

	// COMMENT FORM INITIALIZATION //	
	const blogpostArticle = document.getElementById('blogpost-article')
	const currentBlogId = blogpostArticle?.dataset.blogid;
	const currentUserImg= document.getElementById('comment-current-userimg');
	const currentUserName = document.getElementById('comment-current-username');
	const commentTextArea = document.getElementById('comment-textarea') as HTMLTextAreaElement;
	const commentCount = document.getElementById('comment-textarea-count');
	const commentButton = document.getElementById('comment-textarea-button');
	
	let commentJWT:string | undefined;
	let commentUserInfo:{id:string; name:string; photo:string} | undefined;

	function countCharacters(event : Event, numberDisplay: HTMLElement | null) {
		const target = event.target as HTMLTextAreaElement;
		if (target && numberDisplay) numberDisplay.innerText = (1000 - target.value.length).toString();
	}

	async function postComment(event: Event, blogId:string | undefined, message: string) {
		event.preventDefault();
		if (!blogId || blogId.length < 1) return;

		let userJWT = localStorage.getItem('user_jwt');
		if (userJWT) userJWT = JSON.parse(userJWT).value;

		try {
			const headers = {'Authorization': `Bearer ${userJWT}`}
			await axios.post(`${import.meta.env.PUBLIC_APISITE}/blogposts/${blogId}/comments`, {
				comment: message, createdAt: Date.now()
			}, {headers});

		} catch(err) {
			console.log(err);
			alert('Failed to post your comment. Please try again later.')
		}
	}

	const setUserForComment = () => {
		// get token value and expiration date
		const userJWT = localStorage.getItem('user_jwt');
		if (!userJWT) {
			return;
		};
		const userJWTObj = JSON.parse(userJWT);
		const dateExp = Date.parse(userJWTObj.expires);

		// delete user's data from localStorage if expired
		if (Date.now() > dateExp) {
			localStorage.removeItem('user_jwt');
			localStorage.removeItem('user_info');
			return;
		};
		
		// get current user info
		const userInfo = localStorage.getItem('user_info');
		if (!userInfo) {
			localStorage.removeItem('user_jwt');
			return;
		};
		
		// set user's JWT token and info for comment
		commentJWT = userJWTObj.value;
		commentUserInfo = JSON.parse(userInfo);
	}

	const commentFormInit = () => {
		if (!commentJWT || !commentUserInfo?.id) {
			commentButton?.addEventListener('click', () => window.location.replace('/login'))
		}

		currentUserImg?.setAttribute('src', `${import.meta.env.PUBLIC_IMG_HOST}${commentUserInfo?.photo}`);
		currentUserName!.innerText = commentUserInfo!.name;
		currentUserName!.className = '';
		commentTextArea?.removeAttribute('disabled');
		commentTextArea?.addEventListener('input', (e) => countCharacters(e, commentCount));
		commentButton!.innerText = "Comment"
		commentButton?.addEventListener('click', (e) => postComment(e, currentBlogId, commentTextArea.value))
	};

	setUserForComment();
	commentFormInit()

	// COMMENT CARDS FUNCTIONS //
	// PAGINATION TABS
	const commentContainer = document.getElementById('comment-container');
	const paginationContainer = document.getElementById('pagination-container');
	const loggedinUserId = commentUserInfo?.id || "00"

	const blogComments = new CommentSection(currentBlogId!,  paginationContainer!, commentContainer!, loggedinUserId);
	await blogComments.buildPagination();

	function addPageNumListeners() {
		document.getElementById('pagination-first')?.addEventListener('click', switchToFirstTab);
		document.getElementById('pagination-last')?.addEventListener('click', switchToLastTab);
	}

	function removePageNumListeners() {
		document.getElementById('pagination-first')?.removeEventListener('click', switchToFirstTab);
		document.getElementById('pagination-last')?.removeEventListener('click', switchToLastTab);
	}

	function switchToPrevTab() {
		switchToTabNum(blogComments.currentTab - 1);
	}
	function switchToNextTab() {
		switchToTabNum(blogComments.currentTab + 1);
	}  
	function switchToFirstTab() {
		switchToTabNum(1)
	}
	function switchToLastTab() {
		switchToTabNum(blogComments.commentTabNum)
	}

	const switchToTabNum = (newTabNum: number) => {
		removePageNumListeners();
		removeCommentButtonListeners();
		blogComments.loadTabNum(newTabNum);
		addPageNumListeners();
		registerButtonListeners()
		addCommentButtonListeners()		
	}

	const reloadCommentSection = async (tabJump: number | 'persist' | 'last' = 1) => {
		removePageArrowListeners();
		removePageNumListeners();
		removeCommentButtonListeners();
		await blogComments.buildPagination(tabJump);
		addPageArrowListeners();
		addPageNumListeners();
		registerButtonListeners();
		addCommentButtonListeners();
	}
	
	function addPageArrowListeners() {
		blogComments.paginationContainer.children[0].addEventListener('click', switchToPrevTab);
		blogComments.paginationContainer.children[2].addEventListener('click', switchToNextTab);
	}
	
	function removePageArrowListeners() {
		blogComments.paginationContainer.children[0].removeEventListener('click', switchToPrevTab);
		blogComments.paginationContainer.children[2].removeEventListener('click', switchToNextTab);
	}

	addPageArrowListeners()
	addPageNumListeners()

	// COMMENT CARD BUTTONS
	interface CommentListenerObj {
	[keyIndex: string]: () => void
}
	let buttonListeners: CommentListenerObj = {};
	let commentButtonBoxes: HTMLElement[];

	function registerButtonBoxes() {
		commentButtonBoxes = Array.from(document.getElementsByClassName('commentcard-button-box')) as HTMLElement[];
	}

	const registerButtonListeners = () => {
		registerButtonBoxes();

		commentButtonBoxes.forEach((buttonBox) => {
			const commentIndex = buttonBox.dataset.commentindex || '';
			const commentId = buttonBox.dataset.commentid || '';

			buttonListeners[`edit${commentIndex}`] = () => insertCommentTextarea(commentIndex, commentId);
			buttonListeners[`delete${commentIndex}`] = () => deleteComment(commentId);
			buttonListeners[`cancel${commentIndex}`] = () => cancelEditComment(commentIndex, commentId);
			buttonListeners[`confirm${commentIndex}`] = () => confirmEditComment(commentIndex, commentId)
		})
	}
	
	function insertCommentTextarea(index: string, commentId: string) {
		if (index.length < 1 || commentId.length < 1) return;
		
		document.getElementById(`button-edit-${index}`)?.removeEventListener('click', buttonListeners[`edit${index}`]);
		document.getElementById(`button-delete-${index}`)?.removeEventListener('click', buttonListeners[`delete${index}`]);

		const commentTextbox = document.getElementById(`comment-textbox-${index}`);
		const savedComment = commentTextbox?.dataset.savedcomment || '';
		commentTextbox!.className = 'commentcard-textbox edit';

		const textareaInsert = commentEditArea(index, commentId);
		const parsedInsert = new DOMParser().parseFromString(textareaInsert, 'text/html').body;
		commentTextbox!.innerHTML = parsedInsert.innerHTML;
		const insertedTextarea = document.getElementById(
			`comment-textarea-${index}`
		) as HTMLTextAreaElement;
		insertedTextarea.value = savedComment;

		document.getElementById(`comment-cancel-${index}`)?.addEventListener('click', buttonListeners[`cancel${index}`]);
		document.getElementById(`comment-confirm-${index}`)?.addEventListener('click', buttonListeners[`confirm${index}`]);
	}

	function cancelEditComment(index: string, commentId: string) {
		if (index.length < 1 || commentId.length < 1) return;

		document.getElementById(`comment-cancel-${index}`)?.removeEventListener('click', buttonListeners[`cancel${index}`]);
		document.getElementById(`comment-confirm-${index}`)?.removeEventListener('click', buttonListeners[`confirm${index}`]);

		const commentTextbox = document.getElementById(`comment-textbox-${index}`);
    	const savedComment = commentTextbox?.dataset.savedcomment || '';
		commentTextbox!.className = 'commentcard-textbox';

		const commentContentInsert = commentContent(index, commentId, savedComment);
		const parsedInsert = new DOMParser().parseFromString(commentContentInsert, "text/html").body;
		commentTextbox!.innerHTML = parsedInsert.innerHTML;

		document.getElementById(`button-edit-${index}`)?.addEventListener('click', buttonListeners[`edit${index}`]);
		document.getElementById(`button-delete-${index}`)?.addEventListener('click', buttonListeners[`delete${index}`]);
	}

	async function confirmEditComment(index: string, commentId: string) {
		if (!commentId || commentId.length < 1) return;

		const insertedTextarea = document.getElementById(`comment-textarea-${index}`) as HTMLTextAreaElement;
		const message = insertedTextarea.value;
		try {
			const headers = {'Authorization': `Bearer ${commentJWT}`};
			await axios.patch(`${import.meta.env.PUBLIC_APISITE}/comments/${commentId}`, {comment: message, updatedAt: Date.now()}, {headers});
			
			const commentTextbox = document.getElementById(`comment-textbox-${index}`);
			commentTextbox!.dataset.savedcomment = message;
			buttonListeners[`cancel${index}`]
		} catch(err) {
			console.log(err);
			alert('Failed to edit your comment. Please try again later.')
		}
	}

	async function deleteComment(commentId: string) {
		if (!commentId || commentId.length < 1) return;
		const result = confirm('Are you sure you want to delete?');

		if (result) {
			try {
				const headers = {'Authorization': `Bearer ${commentJWT}`};
				await axios.delete(`${import.meta.env.PUBLIC_APISITE}/comments/${commentId}`, {headers})
				await reloadCommentSection("persist")				
			} catch(err) {
				console.log(err);
				alert('Failed to delete your comment. Please try again later.')
			}
		}
	}

	function addCommentButtonListeners() {
		registerButtonBoxes();

		commentButtonBoxes.forEach((buttonBox) => {
			const commentIndex = buttonBox.dataset.commentindex || '';

			buttonBox.children[0].addEventListener('click', buttonListeners[`edit${commentIndex}`]);
			buttonBox.children[1].addEventListener('click', buttonListeners[`delete${commentIndex}`]);
		})
	}

	function removeCommentButtonListeners() {
		registerButtonBoxes();

		commentButtonBoxes.forEach((buttonBox) => {
			const commentIndex = buttonBox.dataset.commentindex || '';

			if (document.getElementById(`comment-cancel-${commentIndex}`)) {
				buttonBox.children[0].removeEventListener('click', buttonListeners[`cancel${commentIndex}`]);
				buttonBox.children[1].removeEventListener('click', buttonListeners[`confirm${commentIndex}`]);
			} else {
				buttonBox.children[0].removeEventListener('click', buttonListeners[`edit${commentIndex}`]);
				buttonBox.children[1].removeEventListener('click', buttonListeners[`delete${commentIndex}`]);
			}
		})
	}

	registerButtonListeners();
	addCommentButtonListeners();
</script>
